method 1. or brute force 
taking three loops to make every subarray combination and then checking with formula and storing the longest size possible
if (s == k)
                len = max(len, j - i + 1);
        }

method 2. or naive approch
using two loops to make every possible combination and then checking with formula same as above


method 3. or better appproch
using the hash map


method 4. or optimal approch
int getLongestSubarray(vector<int>& a, long long k) {
    int n = a.size(); // size of the array.

    int left = 0, right = 0; // 2 pointers
    long long sum = a[0];
    int maxLen = 0;
    while (right < n) {
        // if sum > k, reduce the subarray from left
        // until sum becomes less or equal to k:
        while (left <= right && sum > k) {
            sum -= a[left];
            left++;
        }

        // if sum = k, update the maxLen i.e. answer:
        if (sum == k) {
            maxLen = max(maxLen, right - left + 1);
        }

        // Move forward thw right pointer:
        right++;
        if (right < n) sum += a[right];
    }

    return maxLen;
}
